import crypto from 'crypto'
import mongoose from 'mongoose'
import { env } from '../config/env'
import * as notificationService from './notification.service'
import type { CampaignMemberStatus, CampaignRole } from '../../shared/types'
const db = () => mongoose.connection.useDb(env.DB_NAME)
const invitesCollection = () => db().collection('campaignInvites')
const inviteTokensCollection = () => db().collection('inviteTokens')

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export type InviteStatus = 'pending' | 'accepted' | 'declined' | 'expired'

export interface CampaignInviteDoc {
  campaignId: mongoose.Types.ObjectId
  invitedUserId: mongoose.Types.ObjectId
  invitedByUserId: mongoose.Types.ObjectId
  role: CampaignRole
  status: CampaignMemberStatus
  createdAt: Date
  respondedAt: Date | null
}

// ---------------------------------------------------------------------------
// Queries
// ---------------------------------------------------------------------------

export async function getInviteById(id: string) {
  return invitesCollection().findOne({
    _id: new mongoose.Types.ObjectId(id),
  })
}

export async function getInvitesForUser(userId: string) {
  return invitesCollection()
    .find({ invitedUserId: new mongoose.Types.ObjectId(userId) })
    .sort({ createdAt: -1 })
    .toArray()
}

export async function getPendingInviteForCampaign(
  campaignId: string,
  invitedUserId: string,
) {
  return invitesCollection().findOne({
    campaignId: new mongoose.Types.ObjectId(campaignId),
    invitedUserId: new mongoose.Types.ObjectId(invitedUserId),
    status: 'pending',
  })
}

// ---------------------------------------------------------------------------
// Commands
// ---------------------------------------------------------------------------

export async function createInvite(data: {
  campaignId: string
  invitedUserId: string
  invitedByUserId: string
  role: CampaignRole
  campaignName: string
  invitedByName: string
}) {
  const existing = await getPendingInviteForCampaign(data.campaignId, data.invitedUserId)
  if (existing) return existing // Don't create duplicate pending invites

  const doc: CampaignInviteDoc = {
    campaignId: new mongoose.Types.ObjectId(data.campaignId),
    invitedUserId: new mongoose.Types.ObjectId(data.invitedUserId),
    invitedByUserId: new mongoose.Types.ObjectId(data.invitedByUserId),
    role: data.role,
    status: 'pending',
    createdAt: new Date(),
    respondedAt: null,
  }

  const result = await invitesCollection().insertOne(doc)
  const invite = await invitesCollection().findOne({ _id: result.insertedId })

  // Create notification for the invited user
  await notificationService.createNotification({
    userId: new mongoose.Types.ObjectId(data.invitedUserId),
    type: 'campaign.invite',
    requiresAction: true,
    context: {
      campaignId: new mongoose.Types.ObjectId(data.campaignId),
      inviteId: result.insertedId,
    },
    payload: {
      campaignName: data.campaignName,
      invitedByName: data.invitedByName,
      role: data.role,
    },
  })

  return invite
}

export async function respondToInvite(
  inviteId: string,
  userId: string,
  accept: boolean,
  characterId?: string,
) {
  const invite = await getInviteById(inviteId)
  if (!invite) return null
  if (invite.invitedUserId.toString() !== userId) return null
  if (invite.status !== 'pending') return invite // Already responded

  if (accept && !characterId) {
    throw new Error('characterId is required when accepting an invite')
  }

  const newStatus: Omit<CampaignMemberStatus, 'declined'> = accept ? 'accepted' : 'declined'

  const updatePayload: Record<string, unknown> = {
    status: newStatus,
    respondedAt: new Date(),
  }
  if (accept && characterId) {
    updatePayload.characterId = new mongoose.Types.ObjectId(characterId)
  }

  const updated = await invitesCollection().findOneAndUpdate(
    { _id: new mongoose.Types.ObjectId(inviteId) },
    { $set: updatePayload },
    { returnDocument: 'after' },
  )

  // If accepted, create CampaignMember with status pending (awaiting DM approval)
  if (accept && characterId) {
    const campaignMemberService = await import('./campaignMember.service')
    const role = invite.role === 'dm' ? 'dm' : 'pc'
    const member = await campaignMemberService.createCampaignMember({
      campaignId: invite.campaignId.toString(),
      characterId,
      userId,
      role,
      status: 'pending',
    })

    // Notify campaign admin about character pending approval
    const campaign = await db().collection('campaigns').findOne({ _id: invite.campaignId })
    const character = await db().collection('characters').findOne({ _id: new mongoose.Types.ObjectId(characterId) })
    const invitedUser = await db().collection('users').findOne({ _id: invite.invitedUserId })
    const adminId = campaign?.membership?.adminId
    if (adminId && member && character && invitedUser) {
      await notificationService.createNotification({
        userId: adminId,
        type: 'character_pending_approval',
        requiresAction: true,
        context: {
          campaignId: invite.campaignId,
          campaignMemberId: member._id,
          characterId: member.characterId,
          invitedUserId: invite.invitedUserId,
        },
        payload: {
          characterName: character.name,
          userName: invitedUser.username,
          campaignName: campaign.identity?.name,
        },
      })
    }
  }

  // Mark the associated notification action as taken
  const notification = await db().collection('notifications').findOne({
    userId: invite.invitedUserId,
    type: 'campaign.invite',
    'context.inviteId': invite._id,
  })
  if (notification) {
    await notificationService.markActionTaken(notification._id.toString(), userId)
  }

  return updated
}

// ---------------------------------------------------------------------------
// Invite Tokens â€” for users who don't have an account yet
// ---------------------------------------------------------------------------

export interface InviteTokenDoc {
  token: string
  campaignId: mongoose.Types.ObjectId
  email: string
  invitedByUserId: mongoose.Types.ObjectId
  role: CampaignRole
  expiresAt: Date
  usedAt: Date | null
  usedByUserId: mongoose.Types.ObjectId | null
}

export async function createInviteToken(data: {
  campaignId: string
  email: string
  invitedByUserId: string
  role?: CampaignRole
}): Promise<string> {
  const token = crypto.randomBytes(32).toString('hex')
  const expiresAt = new Date()
  expiresAt.setDate(expiresAt.getDate() + env.INVITE_TOKEN_EXPIRY_DAYS)

  await inviteTokensCollection().insertOne({
    token,
    campaignId: new mongoose.Types.ObjectId(data.campaignId),
    email: data.email,
    invitedByUserId: new mongoose.Types.ObjectId(data.invitedByUserId),
    role: data.role ?? 'pc',
    expiresAt,
    usedAt: null,
    usedByUserId: null,
  } satisfies InviteTokenDoc)

  return token
}

export async function validateInviteToken(token: string) {
  const doc = await inviteTokensCollection().findOne({ token, usedAt: null })
  if (!doc) return null
  if (new Date() > (doc.expiresAt as Date)) return null
  return doc as unknown as InviteTokenDoc & { _id: mongoose.Types.ObjectId }
}

export async function consumeInviteToken(token: string, userId: string) {
  return inviteTokensCollection().findOneAndUpdate(
    { token, usedAt: null },
    { $set: { usedAt: new Date(), usedByUserId: new mongoose.Types.ObjectId(userId) } },
    { returnDocument: 'after' },
  )
}
