---
alwaysApply: true
--- 

# Project Architecture & Code Organization Directives

This project follows a **domain-first architecture**.

The goal is to clearly separate:
- game rules & business logic
- UI and feature orchestration
- static rule data
- infrastructure concerns

Cursor should follow the rules below when generating or refactoring code.

---

## 1. Domain Layer (`src/domain`)

### Purpose
The `domain` layer contains **pure game rules and business logic**.

Code in `src/domain`:
- MUST be framework-agnostic
- MUST NOT import from React, MUI, hooks, context, or UI components
- SHOULD be reusable by frontend and backend
- SHOULD be deterministic and side-effect free

### What belongs here
- XP rules
- class requirements
- level progression
- equipment cost, weight, and transfer rules
- visibility and permission rules (non-auth)
- lookup helpers that are not UI-specific

### File conventions
- One file per rule concept
- Prefer simple, semantic names:
  - `xp.ts`
  - `classRequirements.ts`
  - `levelProgression.ts`
  - `transfer.ts`
- Group by domain concept:
  - `domain/character/*`
  - `domain/equipment/*`
  - `domain/lookups/*`

### Example
```ts
domain/character/xp.ts
domain/equipment/transfer.ts
```

## 2. Data vs Domain
### Static rule data

Static, rule-defining constants may live in `domain/*/*.data.ts`.

Examples:
- XP tables
- Level caps
- Alignment enums

### Large catalogs

Large catalogs (classes, races, equipment lists) may remain in `src/data` for now.

Cursor SHOULD NOT aggressively move large datasets unless explicitly instructed.

## 3. Helpers vs Domain

`src/helpers` is being phased out.

When refactoring:
- If a helper encodes a rule, move it to `src/domain`
- If a helper is UI-specific or formatting-related, keep it outside `src/domain`

Examples:
```
helpers/options/getXpByLevelAndEdition.ts → domain/character/xp.ts
helpers/class/meetsClassRequirements.ts → domain/character/classRequirements.ts
```

## 4. Features Layer (`src/features`)
### Purpose

Features coordinate:
- UI
- state
- domain logic
- API calls

Features MAY import from:
- `src/domain`
- `src/data`
- shared UI components

Features MUST NOT:
- reimplement domain rules
- contain business logic that belongs in `src/domain`

## 5. Shared Components
### Atomic components

Reusable, UI-only components belong in:
- `src/components`

These:
- MUST NOT contain business rules
- MUST NOT import from `src/domain`

## 6. Backend Alignment

Domain logic is expected to be portable to backend services.

Cursor should prefer:

pure functions
- explicit inputs and outputs
- no reliance on browser APIs

## 7. Naming & Intent

Prioritize intent-based naming over technical naming.

Good:
- xp.ts
- transfer.ts
- classRequirements.ts

Avoid:
- utils.ts
- helpers.ts
- misc.ts

## 8. When Unsure

If a file’s responsibility is ambiguous:
- Default to not placing it in domain
- Ask for clarification instead of guessing

Do not invent new architectural layers without instruction.

## 9. Route Responsibilities & Hook Extraction Rules
Route Components (*Route.tsx)

Route components are orchestration layers.

They MAY:
- Read route params
- Call authentication hooks
- Compose feature hooks

Pass data into UI components

They SHOULD NOT:
- Contain large useEffect blocks with data-fetching logic
- Contain complex mutation logic
- Own large groups of related state fields
- Contain business logic

If a route exceeds ~150 lines OR contains:
- More than 1 data-fetching useEffect
- More than 5 pieces of related state
- More than 3 async mutation handlers

Cursor MUST extract logic into a feature hook.

## 10. Presentation Layer & Route Size Limits
Route Rendering Rules

Route components (*Route.tsx) are orchestration layers.

Routes MUST NOT contain large JSX blocks.

If a route contains more than ~150 lines of JSX OR more than 3 major UI sections, Cursor MUST extract presentation into a feature-level view component.

### Feature View Components
Presentation for a feature MUST live in:
`src/features/<feature-name>/`

Example:
`features/character/CharacterView.tsx`

Feature view components:
- MAY render complex JSX
- MAY import shared UI components
- MAY receive state + actions as props
- MUST NOT perform data fetching
- MUST NOT contain business logic
- SHOULD be mostly declarative

### Extraction Pattern
When a route becomes large:
1. Move all JSX into XxxView.tsx
2. Pass required state and actions as props
3. Keep the route focused on:
  - Params
  - Guards
  - Hook composition
  - Loading and error states

After extraction, routes should typically be under 75–100 lines.

### Component Granularity

Large feature views SHOULD be broken into smaller components when:
- A section exceeds ~150 lines
- A section has independent logic
- A section could be reused

Do not create tiny components for trivial markup.

Prioritize readability and cohesion.
